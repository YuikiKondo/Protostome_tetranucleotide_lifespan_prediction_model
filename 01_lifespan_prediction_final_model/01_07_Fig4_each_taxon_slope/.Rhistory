axis.text.y = element_text(size = 20),  # larger y-axis labels
plot.title = element_text(size = 24, hjust = 0.5) # larger title if you add one
)
ggsave("positive_slope_proportions_plot.png", plot = p, width = 8, height = 6, dpi = 300)
# ====== Set working directory ======
setwd("/Users/yuikikondo/Desktop/Github_code/protostome_lifespan_prediction_model/03_BUSCO_Miniprot_gene_average_tetranucleotide_1000folds_seed1_alpha1/Fig4_each_taxon_slope")
# ====== Load required libraries ======
suppressPackageStartupMessages({
library(dplyr)
library(purrr)
library(broom)
library(tidyr)
library(stringr)
library(ggplot2)
})
# ---------- Reusable all-black (not bold) theme ----------
theme_all_black <- theme_classic(base_size = 18) +
theme(
plot.title        = element_text(color = "black"),
axis.title        = element_text(color = "black"),
axis.text.x       = element_text(color = "black", size = 18),
axis.text.y       = element_text(color = "black", size = 18),
legend.title      = element_text(color = "black"),
legend.text       = element_text(color = "black"),
strip.text        = element_text(color = "black"),
axis.line         = element_line(color = "black", linewidth = 0.6),
axis.ticks        = element_line(color = "black", linewidth = 0.6),
axis.ticks.length = unit(4, "pt"),
panel.grid.major  = element_blank(),
panel.grid.minor  = element_blank()
)
# ====== Step 1: Read data ======
predictions <- read.csv("log_lifespan_predictions_with_taxonomy.csv")
# ====== Step 1.5: Merge Arthropoda groups ======
predictions <- predictions %>%
mutate(
Phylum = case_when(
Phylum %in% c("Arthropoda (Chelicerata)", "Arthropoda (Mandibulata)") ~ "Arthropoda",
TRUE ~ Phylum
)
)
# ====== NEW: switch to ln(years) from ln(days) ======
# ln(years) = ln(days) - ln(365)
L365 <- log(365)
predictions <- predictions %>%
mutate(
Known_Log_Lifespan_years     = Known_Log_Lifespan - L365,
Predicted_Log_Lifespan_years = Predicted_Log_Lifespan_Model_Averaging - L365
)
# ====== Step 2: Filter for Train and Test datasets ======
filtered_data <- predictions %>%
filter(Dataset %in% c("Train", "Test"))
# ====== Step 3: Define taxonomic levels ======
taxonomic_levels <- c("Phylum", "Class", "Order", "Family", "Genus")
# ====== Step 4: Define function to compute slope per group (using ln-years) ======
compute_slope_by_level <- function(level) {
higher_levels <- taxonomic_levels[1:which(taxonomic_levels == level) - 1]
# 1) Canonical (most frequent) lineage per focal group
if (length(higher_levels) > 0) {
lineage_table <- filtered_data %>%
filter(!is.na(.data[[level]])) %>%
count(across(all_of(c(level, higher_levels))), name = "n") %>%
arrange(desc(n)) %>%
group_by(across(all_of(level))) %>%
slice_head(n = 1) %>%
ungroup() %>%
select(-n)
} else {
lineage_table <- filtered_data %>%
filter(!is.na(.data[[level]])) %>%
distinct(across(all_of(level)))
}
# 2) Slope per focal group (ln-years)
result <- filtered_data %>%
filter(!is.na(.data[[level]])) %>%
group_by(across(all_of(level))) %>%
mutate(n_species = n()) %>%
ungroup() %>%
filter(n_species > 2) %>%
group_by(across(all_of(level))) %>%
nest() %>%
mutate(
n_species = map_int(data, nrow),
model = map(data, ~ lm(Predicted_Log_Lifespan_years ~ Known_Log_Lifespan_years, data = .x)),
slope = map_dbl(model, ~ coef(.x)[["Known_Log_Lifespan_years"]]),
mse = map_dbl(data, ~ mean((.x$Predicted_Log_Lifespan_years - .x$Known_Log_Lifespan_years)^2)),
mae = map_dbl(data, ~ mean(abs(.x$Predicted_Log_Lifespan_years - .x$Known_Log_Lifespan_years))),
mean_error = map_dbl(data, ~ mean(.x$Predicted_Log_Lifespan_years - .x$Known_Log_Lifespan_years)),
Max_Known_Lifespan = map_dbl(data, ~ max(.x$Known_Log_Lifespan_years, na.rm = TRUE)),
Min_Known_Lifespan = map_dbl(data, ~ min(.x$Known_Log_Lifespan_years, na.rm = TRUE)),
Max_minus_Min_Known_Lifespan = Max_Known_Lifespan - Min_Known_Lifespan
) %>%
select(all_of(level), n_species, slope, mse, mae, mean_error,
Max_Known_Lifespan, Min_Known_Lifespan, Max_minus_Min_Known_Lifespan) %>%
ungroup()
# 3) Join single canonical lineage
result <- result %>%
left_join(lineage_table, by = level) %>%
mutate(Level = level) %>%
relocate(all_of(c(level, higher_levels)), .before = n_species)
result %>% distinct(across(all_of(level)), .keep_all = TRUE)
}
# ====== Step 4.5: Compute slope for ALL species ("Protostomia") in ln-years ======
compute_slope_all <- function() {
dat <- filtered_data %>%
select(Known_Log_Lifespan_years, Predicted_Log_Lifespan_years)
n_species <- nrow(dat)
mdl <- lm(Predicted_Log_Lifespan_years ~ Known_Log_Lifespan_years, data = dat)
tibble::tibble(
Level = "Protostomia",
n_species = n_species,
slope = coef(mdl)[["Known_Log_Lifespan_years"]],
mse = mean((dat$Predicted_Log_Lifespan_years - dat$Known_Log_Lifespan_years)^2),
mae = mean(abs(dat$Predicted_Log_Lifespan_years - dat$Known_Log_Lifespan_years)),
mean_error = mean(dat$Predicted_Log_Lifespan_years - dat$Known_Log_Lifespan_years),
Max_Known_Lifespan = max(dat$Known_Log_Lifespan_years, na.rm = TRUE),
Min_Known_Lifespan = min(dat$Known_Log_Lifespan_years, na.rm = TRUE),
Max_minus_Min_Known_Lifespan = Max_Known_Lifespan - Min_Known_Lifespan
)
}
# ====== Step 5: Compute slopes and save CSVs ======
slope_summary_all <- list()
for (level in taxonomic_levels) {
result <- compute_slope_by_level(level)
result$Level <- level
filename <- paste0("slope_by_", tolower(level), "_ln_years.csv")  # renamed to reflect units
write.csv(dplyr::select(result, -any_of("Level")), filename, row.names = FALSE)
cat("Saved:", filename, "\n")
slope_summary_all[[level]] <- result
}
all_res <- compute_slope_all()
write.csv(dplyr::select(all_res, -any_of("Level")),
"slope_all_protostomia_ln_years.csv", row.names = FALSE)
cat("Saved: slope_all_protostomia_ln_years.csv\n")
slope_summary_all[["Protostomia"]] <- all_res
# ====== Step 6: Combine all into a single dataframe ======
slope_summary_all_df <- bind_rows(slope_summary_all)
# ====== Step 7: Add slope direction ======
slope_summary_all_df <- slope_summary_all_df %>%
mutate(SlopeDirection = ifelse(is.na(slope), NA, ifelse(slope >= 0, "Positive", "Negative")))
# ====== Step 8: Calculate Positive Proportions (include Protostomia) ======
level_order <- c("Protostomia", taxonomic_levels)
positive_proportion <- slope_summary_all_df %>%
group_by(Level) %>%
summarise(
total_groups = n(),
positive_groups = sum(SlopeDirection == "Positive", na.rm = TRUE),
Proportion_Positive = positive_groups / total_groups,
.groups = "drop"
) %>%
mutate(Level = factor(Level, levels = level_order)) %>%
arrange(Level)
# ====== Step 9: Save Positive Proportions ======
cat("\nProportion of Positive Slopes by Level:\n")
print(positive_proportion)
write.csv(positive_proportion, "positive_slope_proportions_by_level_ln_years.csv", row.names = FALSE)
cat("Saved: positive_slope_proportions_by_level_ln_years.csv\n")
# ====== Step 10: Wilcoxon tests only (one-sided: greater than zero) ======
suppressWarnings({
slope_wilcoxon_tests <- slope_summary_all_df %>%
dplyr::group_by(Level) %>%
dplyr::group_modify(~{
x <- .x$slope[is.finite(.x$slope)]
n <- length(x)
if (n > 2) {
wt <- tryCatch(
stats::wilcox.test(x, mu = 0, alternative = "greater"),
error = function(e) NULL
)
tibble::tibble(
n = n,
median_slope = stats::median(x, na.rm = TRUE),
mean_slope = mean(x, na.rm = TRUE),
mean_mse = mean(.x$mse, na.rm = TRUE),
wilcox_W = ifelse(is.null(wt), NA_real_, unname(wt$statistic)),
wilcox_p_value = ifelse(is.null(wt), NA_real_, wt$p.value),
test_description = "Wilcoxon signed-rank test (median slope > 0, one-sided)"
)
} else {
tibble::tibble(
n = n,
median_slope = stats::median(x, na.rm = TRUE),
mean_slope = mean(x, na.rm = TRUE),
mean_mse = mean(.x$mse, na.rm = TRUE),
wilcox_W = NA_real_,
wilcox_p_value = NA_real_,
test_description = "Wilcoxon signed-rank test (median slope > 0, one-sided)"
)
}
}) %>%
dplyr::ungroup() %>%
dplyr::mutate(Level = factor(Level, levels = c("Protostomia", taxonomic_levels))) %>%
dplyr::arrange(Level)
})
print(slope_wilcoxon_tests)
write.csv(slope_wilcoxon_tests, "slope_wilcoxon_tests_by_level_ln_years.csv", row.names = FALSE)
cat("Saved: slope_wilcoxon_tests_by_level_ln_years.csv\n")
# ====== Step 11: Prepare slope count data for plotting ======
slope_count_plot_data <- slope_summary_all_df %>%
filter(SlopeDirection %in% c("Positive", "Negative")) %>%
group_by(Level, SlopeDirection) %>%
summarise(n = n(), .groups = "drop")
# ====== Step 12: Plot Positive vs Negative Slope Counts (ln-years label) ======
ggplot(slope_count_plot_data, aes(x = Level, y = n, fill = SlopeDirection)) +
geom_bar(stat = "identity",
position = position_dodge(width = 0.9),
width = 0.8,
color = "black") +
scale_fill_manual(values = c("Positive" = "#D55E00", "Negative" = "#009E73")) +
scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
geom_hline(yintercept = 0, color = "black") +
labs(x = "Taxonomic Level", y = "Number of Groups", fill = "Slope Direction") +
theme_all_black +
theme(axis.line.x = element_blank())
ggsave("slope_direction_by_taxonomic_level_ln_years.png", width = 10, height = 6)
# ====== Step 13: Plot Proportion of Positive Slopes ======
ggplot(positive_proportion, aes(x = Level, y = Proportion_Positive)) +
geom_bar(stat = "identity", fill = "grey60", color = "black", width = 0.7) +
scale_y_continuous(limits = c(0, 1), expand = expansion(mult = c(0, 0.05))) +
geom_hline(yintercept = 0, color = "black") +
geom_hline(yintercept = 0.5, linetype = "dashed", color = "black", linewidth = 1) +
labs(x = "Taxonomic level", y = "Proportion of groups with positive slope") +
theme_all_black +
theme(
axis.title.x = element_text(size = 28),
axis.title.y = element_text(size = 28),
axis.text.x  = element_text(size = 24),
axis.text.y  = element_text(size = 24),
plot.title   = element_text(size = 24, face = "bold"),
legend.title = element_text(size = 20),
legend.text  = element_text(size = 18)
)
ggsave("positive_slope_proportion_for_each_taxonomic_level_ln_years.png", width = 10, height = 6)
ggplot(positive_proportion, aes(x = Level, y = Proportion_Positive)) +
geom_bar(stat = "identity", fill = "grey60", color = "black", width = 0.7) +
scale_y_continuous(limits = c(0, 1), expand = expansion(mult = c(0, 0.05))) +
geom_hline(yintercept = 0, color = "black") +
geom_hline(yintercept = 0.5, linetype = "dashed", color = "black", linewidth = 1) +
labs(x = "Taxonomic level", y = "Proportion of groups with positive slope") +
theme_all_black +
theme(
axis.title.x = element_text(size = 24),
axis.title.y = element_text(size = 24),
axis.text.x  = element_text(size = 20),
axis.text.y  = element_text(size = 20),
legend.title = element_text(size = 20),
legend.text  = element_text(size = 18)
)
ggsave("positive_slope_proportion_for_each_taxonomic_level_ln_years.png", width = 10, height = 6)
# ====== Step 13: Plot Proportion of Positive Slopes ======
ggplot(positive_proportion, aes(x = Level, y = Proportion_Positive)) +
geom_bar(stat = "identity", fill = "grey60", color = "black", width = 0.7) +
scale_y_continuous(limits = c(0, 1), expand = expansion(mult = c(0, 0.05))) +
geom_hline(yintercept = 0, color = "black") +
geom_hline(yintercept = 0.5, linetype = "dashed", color = "black", linewidth = 1) +
labs(x = "Taxonomic level", y = "Proportion of positive slopes") +
theme_all_black +
theme(
axis.title.x = element_text(size = 24),
axis.title.y = element_text(size = 24),
axis.text.x  = element_text(size = 20),
axis.text.y  = element_text(size = 20),
legend.title = element_text(size = 20),
legend.text  = element_text(size = 18)
)
ggsave("positive_slope_proportion_for_each_taxonomic_level_ln_years.png", width = 10, height = 6)
# ====== Step 13: Plot Proportion of Positive Slopes ======
ggplot(positive_proportion, aes(x = Level, y = Proportion_Positive)) +
geom_bar(stat = "identity", fill = "grey60", color = "black", width = 0.7) +
scale_y_continuous(limits = c(0, 1), expand = expansion(mult = c(0, 0.05))) +
geom_hline(yintercept = 0, color = "black") +
geom_hline(yintercept = 0.5, linetype = "dashed", color = "black", linewidth = 1) +
labs(x = "Taxonomic level", y = "Proportion of positive slope groups") +
theme_all_black +
theme(
axis.title.x = element_text(size = 24),
axis.title.y = element_text(size = 24),
axis.text.x  = element_text(size = 20),
axis.text.y  = element_text(size = 20),
legend.title = element_text(size = 20),
legend.text  = element_text(size = 18)
)
ggsave("positive_slope_proportion_for_each_taxonomic_level_ln_years.png", width = 10, height = 6)
# ====== Set working directory ======
setwd("/Users/yuikikondo/Desktop/Github_code/protostome_lifespan_prediction_model/03_BUSCO_Miniprot_gene_average_tetranucleotide_1000folds_seed1_alpha1/Fig4_each_taxon_slope")
# ===================== Setup =====================
suppressPackageStartupMessages({
library(readr)
library(dplyr)
library(stringr)
library(ggplot2)
library(tidyr)
# ggrepel is optional for labels; uncomment if you want labels later
# library(ggrepel)
})
# ===================== 1) Locate files =====================
# Matches the CSVs you saved in your script
level_files <- list.files(pattern = "^slope_by_(phylum|class|order|family|genus)_ln_years\\.csv$", ignore.case = TRUE)
proto_file  <- "slope_all_protostomia_ln_years.csv"
files_to_read <- c(level_files, if (file.exists(proto_file)) proto_file else character())
if (length(files_to_read) == 0) {
stop("No slope CSV files found in the working directory.")
}
# ===================== 2) Helper to parse Level from filename =====================
parse_level <- function(filename) {
fn <- tolower(filename)
if (str_detect(fn, "protostomia")) return("Protostomia")
m <- str_match(fn, "^slope_by_(phylum|class|order|family|genus)_ln_years\\.csv$")
if (!is.na(m[1,2])) {
# Capitalize first letter
return(str_to_title(m[1,2]))
}
NA_character_
}
# ===================== 3) Read, add Level, combine =====================
slope_df_list <- lapply(files_to_read, function(f) {
df <- read_csv(f, show_col_types = FALSE)
df$Level <- parse_level(f)
df
})
slope_all <- bind_rows(slope_df_list)
# Sanity check required columns
required_cols <- c("slope", "Max_minus_Min_Known_Lifespan", "Level")
missing_cols  <- setdiff(required_cols, colnames(slope_all))
if (length(missing_cols) > 0) {
stop(sprintf("Missing required columns in combined data: %s",
paste(missing_cols, collapse = ", ")))
}
# Optional: ensure the taxon name column exists (for labels if wanted).
# Your per-level files have the focal grouping column named by the Level (e.g., 'Phylum', 'Class', ...).
# We'll create a unified 'Taxon' column by picking whichever of those exists on each row.
taxon_cols <- c("Phylum","Class","Order","Family","Genus")
slope_all <- slope_all %>%
mutate(
Taxon = coalesce(!!!rlang::syms(taxon_cols))  # first non-NA among those columns
)
# Order legend nicely
slope_all <- slope_all %>%
mutate(Level = factor(Level, levels = c("Protostomia","Phylum","Class","Order","Family","Genus")))
# ===================== 4) Plot: Max_minus_Min_Known_Lifespan vs slope =====================
# --- 1) Compute mean slope per Level ---
mean_slope_by_level <- slope_all %>%
group_by(Level) %>%
summarise(mean_slope = mean(slope, na.rm = TRUE), .groups = "drop")
# --- 2) Run one-tailed Wilcoxon tests per Level ---
slope_wilcoxon_tests <- slope_all %>%
group_by(Level) %>%
group_modify(~{
x <- .x$slope[is.finite(.x$slope)]
n <- length(x)
if (n > 2) {
wt <- tryCatch(
stats::wilcox.test(x, mu = 0, alternative = "greater"),
error = function(e) NULL
)
tibble::tibble(
n = n,
wilcox_p = ifelse(is.null(wt), NA_real_, wt$p.value)
)
} else {
tibble::tibble(n = n, wilcox_p = NA_real_)
}
}) %>%
ungroup()
# --- 3) Combine results into one legend label (med., n, p) ---
legend_info <- median_slope_by_level %>%
dplyr::left_join(slope_wilcoxon_tests, by = "Level") %>%
dplyr::mutate(
label = sprintf(
"%s (med. = %.2f, n = %d, p = %.3g)",
as.character(Level), median_slope, n, wilcox_p
)
)
# ====== Set working directory ======
setwd("/Users/yuikikondo/Desktop/Github_code/protostome_lifespan_prediction_model/03_BUSCO_Miniprot_gene_average_tetranucleotide_1000folds_seed1_alpha1/Fig4_each_taxon_slope")
# ===================== Setup =====================
suppressPackageStartupMessages({
library(readr)
library(dplyr)
library(stringr)
library(ggplot2)
library(tidyr)
# ggrepel is optional for labels; uncomment if you want labels later
# library(ggrepel)
})
# ===================== 1) Locate files =====================
# Matches the CSVs you saved in your script
level_files <- list.files(pattern = "^slope_by_(phylum|class|order|family|genus)_ln_years\\.csv$", ignore.case = TRUE)
proto_file  <- "slope_all_protostomia_ln_years.csv"
files_to_read <- c(level_files, if (file.exists(proto_file)) proto_file else character())
if (length(files_to_read) == 0) {
stop("No slope CSV files found in the working directory.")
}
# ===================== 2) Helper to parse Level from filename =====================
parse_level <- function(filename) {
fn <- tolower(filename)
if (str_detect(fn, "protostomia")) return("Protostomia")
m <- str_match(fn, "^slope_by_(phylum|class|order|family|genus)_ln_years\\.csv$")
if (!is.na(m[1,2])) {
# Capitalize first letter
return(str_to_title(m[1,2]))
}
NA_character_
}
# ===================== 3) Read, add Level, combine =====================
slope_df_list <- lapply(files_to_read, function(f) {
df <- read_csv(f, show_col_types = FALSE)
df$Level <- parse_level(f)
df
})
slope_all <- bind_rows(slope_df_list)
# Sanity check required columns
required_cols <- c("slope", "Max_minus_Min_Known_Lifespan", "Level")
missing_cols  <- setdiff(required_cols, colnames(slope_all))
if (length(missing_cols) > 0) {
stop(sprintf("Missing required columns in combined data: %s",
paste(missing_cols, collapse = ", ")))
}
# Optional: ensure the taxon name column exists (for labels if wanted).
# Your per-level files have the focal grouping column named by the Level (e.g., 'Phylum', 'Class', ...).
# We'll create a unified 'Taxon' column by picking whichever of those exists on each row.
taxon_cols <- c("Phylum","Class","Order","Family","Genus")
slope_all <- slope_all %>%
mutate(
Taxon = coalesce(!!!rlang::syms(taxon_cols))  # first non-NA among those columns
)
# Order legend nicely
slope_all <- slope_all %>%
mutate(Level = factor(Level, levels = c("Protostomia","Phylum","Class","Order","Family","Genus")))
# ===================== 4) Plot: Max_minus_Min_Known_Lifespan vs slope =====================
# ===================== 4) Plot: Max_minus_Min_Known_Lifespan vs slope =====================
# --- 1) Compute median slope per Level ---
median_slope_by_level <- slope_all %>%
dplyr::group_by(Level) %>%
dplyr::summarise(median_slope = median(slope, na.rm = TRUE), .groups = "drop")
# --- 2) Run one-tailed Wilcoxon tests per Level (median slope > 0) ---
slope_wilcoxon_tests <- slope_all %>%
dplyr::group_by(Level) %>%
dplyr::group_modify(~{
x <- .x$slope[is.finite(.x$slope)]
n <- length(x)
if (n > 2) {
wt <- tryCatch(
stats::wilcox.test(x, mu = 0, alternative = "greater"),
error = function(e) NULL
)
tibble::tibble(
n = n,
wilcox_p = ifelse(is.null(wt), NA_real_, wt$p.value)
)
} else {
tibble::tibble(n = n, wilcox_p = NA_real_)
}
}) %>%
dplyr::ungroup()
# --- 3) Combine results into one legend label (median, n, p) ---
legend_info <- median_slope_by_level %>%
dplyr::left_join(slope_wilcoxon_tests, by = "Level") %>%
dplyr::mutate(
label = sprintf(
"%s (median slope = %.2f, n = %d, p = %.3g)",
as.character(Level), median_slope, n, wilcox_p
)
)
# --- 4) Build mapping for discrete scales ---
lab_map <- setNames(legend_info$label, legend_info$Level)
legend_breaks <- levels(slope_all$Level)
# --- 5) Plot with updated legend labels (save main + legend separately) ---
suppressPackageStartupMessages({
library(cowplot)
library(ggplotify)
})
# Base plot (without legend)
p_main <- ggplot(
slope_all,
aes(x = Max_minus_Min_Known_Lifespan, y = slope,
color = Level, shape = Level)
) +
geom_hline(yintercept = 0, linetype = "dashed", linewidth = 0.6, color = "black") +
geom_point(size = 3, alpha = 0.9) +
theme_all_black +
theme(
axis.title.x  = element_text(size = 30, color = "black"),
axis.title.y  = element_text(size = 30, color = "black"),
axis.text.x   = element_text(size = 26, color = "black"),
axis.text.y   = element_text(size = 26, color = "black"),
legend.position = "none"
) +
labs(
x = "Lifespan range within group (ln[max/min])",
y = "Slope (Predicted ~ Known lifespan)"
) +
scale_color_discrete(breaks = legend_breaks, labels = lab_map[legend_breaks]) +
scale_shape_discrete(breaks = legend_breaks, labels = lab_map[legend_breaks])
ggsave("scatter_slope_vs_lifespan_range_main.png",
p_main, width = 12, height = 8, dpi = 300)
# Legend only (with roomier spacing)
p_with_legend <- p_main +
theme(
legend.position   = "right",
legend.title      = element_text(size = 22, color = "black"),
legend.text       = element_text(size = 18, color = "black", lineheight = 1.6),
legend.key.height = unit(26, "pt"),
legend.key.width  = unit(20, "pt")
)
legend_only <- cowplot::get_legend(p_with_legend)
ggsave("scatter_slope_vs_lifespan_range_legend.png",
legend_only, width = 6.8, height = 8.6, dpi = 300, bg = "white")
# slope as response
m1 <- lm(slope ~ Level + Max_minus_Min_Known_Lifespan, data = slope_all)
library(car)
Anova(m1, type = "II")   # gives sums of squares type II
