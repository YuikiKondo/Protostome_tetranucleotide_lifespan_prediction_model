set.seed(1)  # keep reproducible
additional_test_indices <- sample(remaining_indices, size = additional_test_needed)
fold_test_indices <- c(test_indices_priority, additional_test_indices)
} else {
fold_test_indices <- test_indices_priority
}
# Prepare the 1000th fold training and test sets
fold_train_indices <- setdiff(seq_len(nrow(train_data)), fold_test_indices)
fold_train_data <- train_data[fold_train_indices, ]
fold_test_data  <- train_data[fold_test_indices, ]
# Predictor matrices and response vectors
x_train <- fold_train_data %>%
select(-c(Organism.Name, Lifespan, log_lifespan)) %>%
as.matrix()
y_train <- fold_train_data$log_lifespan
x_test <- fold_test_data %>%
select(-c(Organism.Name, Lifespan, log_lifespan)) %>%
as.matrix()
y_test <- fold_test_data$log_lifespan
# Ensure columns/order match between training and test sets
x_test <- x_test[, colnames(x_train), drop = FALSE]
# Step 9: Inner cross-validation for model selection (1000th fold) using cva.glmnet
best_model  <- NULL
best_lambda <- NULL
best_alpha  <- NULL
best_cvm    <- Inf
cv_model <- cva.glmnet(x_train, y_train, alpha = 1,
family = "gaussian", nfolds = 10, nlambda = 100)
for (idx in seq_along(cv_model$modlist)) {
mod <- cv_model$modlist[[idx]]       # cv.glmnet object
alpha_val <- cv_model$alpha[idx]
lambda_1se <- mod$lambda.1se
if (min(mod$cvm) < best_cvm) {
best_cvm    <- min(mod$cvm)
best_model  <- mod
best_lambda <- lambda_1se
best_alpha  <- alpha_val
}
}
# Named coefficients (including intercept) for the 1000th fold
coefs_this_fold <- as.matrix(coef(best_model, s = best_lambda))
coef_vec_named  <- setNames(as.numeric(coefs_this_fold[, 1]),
rownames(coefs_this_fold))
# Step 10: Predict on training and test data for the 1000th fold
pred_train <- as.numeric(predict(best_model, newx = x_train, s = best_lambda))
pred_test  <- as.numeric(predict(best_model, newx  = x_test,  s = best_lambda))
train_mae_years <- mean(abs((exp(y_train) - exp(pred_train)) / 365), na.rm = TRUE)
test_mae_years  <- mean(abs((exp(y_test)  - exp(pred_test))  / 365), na.rm = TRUE)
# Store the test predictions for the 1000th fold
fold_predictions[fold_test_indices, 1000] <- pred_test
# Step 10.1: Predict the final [30% test] set (align columns to x_train)
x_final_test <- test_data %>%
select(-c(Organism.Name, Lifespan, log_lifespan)) %>%
as.matrix()
x_final_test <- x_final_test[, colnames(x_train), drop = FALSE]
pred_final_test <- as.numeric(predict(best_model, newx = x_final_test, s = best_lambda))
fold_predictions_final_test_set[, 1000] <- pred_final_test
# Step 10.2: Store the 1000th fold results in outer_results (with named coefs)
outer_results[[1000]] <- list(
coef_vec   = coef_vec_named,     # named vector, includes "(Intercept)"
best_lambda = best_lambda,
best_alpha  = best_alpha,
train_corr  = cor(y_train, pred_train),
test_corr   = cor(y_test,  pred_test),
train_mse   = mean((y_train - pred_train)^2),
test_mse    = mean((y_test  - pred_test )^2),
train_mae_years = train_mae_years,
test_mae_years  = test_mae_years
)
# Step 11: Bagging predictions by averaging the fold predictions (for training data)
bagging_predictions_train <- rowMeans(fold_predictions, na.rm = TRUE)
# ===== Step 12: Build a name-safe coefficient table across folds =====
# Union of all coefficient names across folds (keeps "(Intercept)")
all_coef_names <- unique(unlist(lapply(outer_results, function(x) names(x$coef_vec))))
# One row per coefficient name; one column per fold
weight_df <- data.frame(Feature_Name = all_coef_names, stringsAsFactors = FALSE)
for (i in seq_along(outer_results)) {
v <- outer_results[[i]]$coef_vec           # named vector incl. "(Intercept)"
# default to 0 for coefficients not present in this fold
weight_df[[paste0("Fold_", i)]] <- ifelse(all_coef_names %in% names(v), v[all_coef_names], 0)
}
# Average weight across folds (0 for unselected in a fold)
fold_cols <- paste0("Fold_", seq_along(outer_results))
weight_df$Average_Weight <- rowMeans(weight_df[, fold_cols, drop = FALSE], na.rm = TRUE)
# ===== Step 13: Mean predictor value & correlations (all species + train-only) =====
# Combine definitive train and test data (only species with lifespan values)
data_definitive <- bind_rows(data_definitive_train, data_definitive_test) %>%
mutate(log_lifespan = log(Lifespan))   # Recalculate log_lifespan (no -Inf)
# Predictor columns (exclude metadata)
predictor_columns <- colnames(
data_definitive %>% select(-c(Organism.Name, Lifespan, log_lifespan))
)
# 1) Mean feature values across all definitive species
mean_nucleotide_rate_values <- data_definitive %>%
select(all_of(predictor_columns)) %>%
summarize(across(everything(), ~ mean(as.numeric(.), na.rm = TRUE))) %>%
tidyr::gather(key = "Feature_Name", value = "Mean_Feature_Value_Across_All_Species")
# 2) Correlations (all definitive species)
correlations_all <- sapply(predictor_columns, function(g) {
cor(data_definitive$log_lifespan, as.numeric(data_definitive[[g]]), use = "complete.obs")
})
correlation_df_all <- data.frame(
Feature_Name = names(correlations_all),
Lifespan_Feature_Correlation_All_Species = correlations_all,
stringsAsFactors = FALSE
)
# 3) Correlations (train-only definitive species)
data_definitive_train_only <- data_definitive_train %>%
select(any_of(c("Organism.Name", "Lifespan", predictor_columns))) %>%
mutate(log_lifespan = log(Lifespan))
correlations_train <- sapply(predictor_columns, function(g) {
cor(data_definitive_train_only$log_lifespan,
as.numeric(data_definitive_train_only[[g]]),
use = "complete.obs")
})
correlation_df_train <- data.frame(
Feature_Name = names(correlations_train),
Lifespan_Feature_Correlation_Train_Species = correlations_train,
stringsAsFactors = FALSE
)
# ===== Step 14: Merge into combined_weights_df =====
combined_weights_df <- weight_df %>%
dplyr::left_join(mean_nucleotide_rate_values, by = "Feature_Name") %>%
dplyr::left_join(correlation_df_all, by = "Feature_Name") %>%
dplyr::left_join(correlation_df_train, by = "Feature_Name")
# (Optional) selection stability metrics remain the same
combined_weights_df$Selection_Frequency <- rowMeans(combined_weights_df[, fold_cols] != 0, na.rm = TRUE)
combined_weights_df$SD_Weight <- apply(combined_weights_df[, fold_cols, drop = FALSE], 1, sd)
# ===== Step 15: Save combined model weights =====
write.csv(combined_weights_df, "combined_model_weights.csv", row.names = FALSE)
# ===== Step 16: Prepare final averaged weights (separate intercept) =====
# Intercept from averaged coefficients (default 0 if missing)
intercept <- combined_weights_df$Average_Weight[combined_weights_df$Feature_Name == "(Intercept)"]
intercept <- ifelse(length(intercept) == 0, 0, as.numeric(intercept))
# Final averaged coefficients for predictors only (drop intercept)
final_coef_df <- combined_weights_df %>%
dplyr::filter(Feature_Name != "(Intercept)") %>%
dplyr::select(Feature_Name, Average_Weight)
# Build train/test matrices and align columns to the coefficient names
x_train_data <- train_data %>%
dplyr::select(-c(Organism.Name, Lifespan, log_lifespan)) %>%
as.matrix()
x_test_data <- test_data %>%
dplyr::select(-c(Organism.Name, Lifespan, log_lifespan)) %>%
as.matrix()
# Keep only predictors that exist in both matrix and final_coef_df; ensure same order
keep_cols <- intersect(colnames(x_train_data), final_coef_df$Feature_Name)
final_coef_df <- final_coef_df[match(keep_cols, final_coef_df$Feature_Name), , drop = FALSE]
x_train_data_filtered <- x_train_data[, keep_cols, drop = FALSE]
x_test_data_filtered  <- x_test_data[,  keep_cols, drop = FALSE]
# Coefficient vector in matching order
final_weights_filtered <- as.numeric(final_coef_df$Average_Weight)
# Predictions (model averaging)
predicted_log_lifespan_train <- as.numeric(intercept + x_train_data_filtered %*% final_weights_filtered)
predicted_log_lifespan_test  <- as.numeric(intercept + x_test_data_filtered  %*% final_weights_filtered)
# ===== Step 17–18: Create combined results for predictions and save =====
train_results <- data.frame(
Organism_Name = train_data$Organism.Name,
Dataset = "Train",
Known_Log_Lifespan = train_data$log_lifespan,
Predicted_Log_Lifespan_Model_Averaging = predicted_log_lifespan_train,
Predicted_Log_Lifespan_Bagging = bagging_predictions_train
)
test_results <- data.frame(
Organism_Name = test_data$Organism.Name,
Dataset = "Test",
Known_Log_Lifespan = test_data$log_lifespan,
Predicted_Log_Lifespan_Model_Averaging = predicted_log_lifespan_test,
Predicted_Log_Lifespan_Bagging = NA  # will be filled later by final-test bagging
)
combined_results <- rbind(train_results, test_results)
# ===== Step 19: Save initial predictions (will be augmented later) =====
write.csv(combined_results, "log_lifespan_predictions.csv", row.names = FALSE)
# ===== Step 25: Add per-fold predictions (train folds) to combined_results =====
for (i in 1:ncol(fold_predictions)) {
combined_results[[paste0("Fold_", i, "_Prediction")]] <-
c(fold_predictions[, i], rep(NA, nrow(test_data)))
}
# ===== Step 26: Add per-fold predictions for the final [30% test] set =====
for (i in 1:ncol(fold_predictions_final_test_set)) {
combined_results[[paste0("Fold_", i, "_Final_Test_Prediction")]] <-
c(rep(NA, nrow(train_data)), fold_predictions_final_test_set[, i])
}
# ===== Step 27: Bagging predictions for the final [30% test] set =====
final_test_bagging_predictions <- rowMeans(fold_predictions_final_test_set, na.rm = TRUE)
# ===== Step 28: Update test rows' bagging predictions =====
combined_results$Predicted_Log_Lifespan_Bagging[(nrow(train_data) + 1):nrow(combined_results)] <-
final_test_bagging_predictions
# ===== Step 29: Save the augmented predictions file =====
write.csv(combined_results, "log_lifespan_predictions_with_folds.csv", row.names = FALSE)
# ======================= METRICS (Step 20–22) =======================
# --- Model-averaging metrics ---
train_pearson_corr_model_avg <- cor(train_data$log_lifespan, predicted_log_lifespan_train, use = "complete.obs")
train_mse_model_avg          <- mean((train_data$log_lifespan - predicted_log_lifespan_train)^2)
train_mae_model_avg          <- mean(abs((exp(train_data$log_lifespan) - exp(predicted_log_lifespan_train)) / 365), na.rm = TRUE)
test_pearson_corr_model_avg  <- cor(test_data$log_lifespan,  predicted_log_lifespan_test,  use = "complete.obs")
test_mse_model_avg           <- mean((test_data$log_lifespan  - predicted_log_lifespan_test)^2)
test_mae_model_avg           <- mean(abs((exp(test_data$log_lifespan) - exp(predicted_log_lifespan_test)) / 365), na.rm = TRUE)
# --- Bagging metrics ---
train_pearson_corr_bagging <- cor(train_data$log_lifespan, bagging_predictions_train, use = "complete.obs")
train_mse_bagging          <- mean((train_data$log_lifespan - bagging_predictions_train)^2)
train_mae_bagging          <- mean(abs((exp(train_data$log_lifespan) - exp(bagging_predictions_train)) / 365), na.rm = TRUE)
test_pearson_corr_bagging  <- cor(test_data$log_lifespan, final_test_bagging_predictions, use = "complete.obs")
test_mse_bagging           <- mean((test_data$log_lifespan  - final_test_bagging_predictions)^2)
test_mae_bagging           <- mean(abs((exp(test_data$log_lifespan) - exp(final_test_bagging_predictions)) / 365), na.rm = TRUE)
# --- Per-fold metrics table from outer_results ---
per_fold <- data.frame(
Fold             = paste0("Fold_", seq_along(outer_results)),
Train_Pearson_Corr = sapply(outer_results, function(x) x$train_corr),
Test_Pearson_Corr  = sapply(outer_results, function(x) x$test_corr),
Train_MSE          = sapply(outer_results, function(x) x$train_mse),
Test_MSE           = sapply(outer_results, function(x) x$test_mse),
Train_MAE          = sapply(outer_results, function(x) x$train_mae_years),  # years
Test_MAE           = sapply(outer_results, function(x) x$test_mae_years),   # years
Alpha              = sapply(outer_results, function(x) x$best_alpha),
Lambda             = sapply(outer_results, function(x) x$best_lambda),
Num_Features       = sapply(outer_results, function(x) {
v <- x$coef_vec
sum(v[names(v) != "(Intercept)"] != 0)
})
)
# --- Summary rows ---
final_model_row_train_avg <- data.frame(
Fold = "70%_Train_Data_Model_Averaging",
Train_Pearson_Corr = train_pearson_corr_model_avg,
Test_Pearson_Corr  = NA,
Train_MSE          = train_mse_model_avg,
Test_MSE           = NA,
Train_MAE          = train_mae_model_avg,
Test_MAE           = NA,
Alpha              = NA,
Lambda             = NA,
Num_Features       = sum(
(combined_weights_df$Feature_Name != "(Intercept)") &
(combined_weights_df$Average_Weight != 0),
na.rm = TRUE
)
)
final_model_row_test_avg <- data.frame(
Fold = "30%_Holdout_Test_Data_Model_Averaging",
Train_Pearson_Corr = NA,
Test_Pearson_Corr  = test_pearson_corr_model_avg,
Train_MSE          = NA,
Test_MSE           = test_mse_model_avg,
Train_MAE          = NA,
Test_MAE           = test_mae_model_avg,
Alpha              = NA,
Lambda             = NA,
Num_Features       = final_model_row_train_avg$Num_Features
)
final_model_row_train_bagging <- data.frame(
Fold = "70%_Train_Data_Bagging_(test_data_in_each_fold)",
Train_Pearson_Corr = NA,
Test_Pearson_Corr  = train_pearson_corr_bagging,
Train_MSE          = NA,
Test_MSE           = train_mse_bagging,
Train_MAE          = NA,
Test_MAE           = train_mae_bagging,
Alpha              = NA,
Lambda             = NA,
Num_Features       = NA
)
final_model_row_test_bagging <- data.frame(
Fold = "30%_Holdout_Test_Data_Bagging",
Train_Pearson_Corr = NA,
Test_Pearson_Corr  = test_pearson_corr_bagging,
Train_MSE          = NA,
Test_MSE           = test_mse_bagging,
Train_MAE          = NA,
Test_MAE           = test_mae_bagging,
Alpha              = NA,
Lambda             = NA,
Num_Features       = NA
)
model_metrics <- rbind(
per_fold,
final_model_row_train_avg,
final_model_row_test_avg,
final_model_row_train_bagging,
final_model_row_test_bagging
)
write.csv(model_metrics, "model_metrics.csv", row.names = FALSE)
# Step 23: Combine training and test results for plotting
plot_data <- rbind(
data.frame(
Organism_Name = train_data$Organism.Name,
Known_Log_Lifespan = train_data$log_lifespan,
Predicted_Log_Lifespan = predicted_log_lifespan_train,
Set = "Train"
),
data.frame(
Organism_Name = test_data$Organism.Name,
Known_Log_Lifespan = test_data$log_lifespan,
Predicted_Log_Lifespan = predicted_log_lifespan_test,
Set = "Test"
)
)
# Step 24: Create the scatter plot using ggplot2
ggplot(plot_data, aes(x = Known_Log_Lifespan, y = Predicted_Log_Lifespan, color = Set)) +
geom_point(alpha = 0.7, size = 3) +
geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # Reference line for y = x
labs(title = "Scatterplot of Known vs Predicted Log Lifespan",
x = "Known Log Lifespan",
y = "Predicted Log Lifespan") +
theme_minimal() +
theme(
axis.title.x = element_text(size = 14),
axis.title.y = element_text(size = 14),
plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
legend.title = element_blank(),
legend.text = element_text(size = 12)
) +
scale_color_manual(values = c("Train" = "blue", "Test" = "red"))  # Custom colors for Train and Test sets
ggsave("scatterplot_lifespan.png", width = 8, height = 6, dpi = 300)
################################################################################
setwd("/Users/yuikikondo/Desktop/Github_code/protostome_lifespan_prediction_model/06_cross_clade_models_by_Ecdysozoa_and_Spiralia/06_03_Trian_by_Spiralia_Test_by_Ecdysozoa")
# ===================== Setup =====================
suppressPackageStartupMessages({
library(readr)
library(dplyr)
library(ggplot2)
library(tidyr)
library(stringr)
})
input_path <- "log_lifespan_predictions.csv"
output_dir <- dirname(input_path)
# Colors for Train/Test
COLORS <- c("Train" = "#00BFC4", "Test" = "#F8766D")
# Helper: safe saver
save_plot <- function(p, fname, w = 7, h = 5, dpi = 300) {
out <- file.path(output_dir, fname)
ggsave(filename = out, plot = p, width = w, height = h, dpi = dpi)
message("Wrote: ", out)
}
# ===================== Load =====================
df <- read_csv(input_path, show_col_types = FALSE)
req_cols <- c("Dataset", "Known_Log_Lifespan", "Predicted_Log_Lifespan_Model_Averaging")
missing <- setdiff(req_cols, names(df))
if (length(missing) > 0) stop("Missing required column(s): ", paste(missing, collapse = ", "))
# Keep a species/name column if present (optional)
species_col <- intersect(c("Organism.Name","Organism_Name","Species","Final_Tip_Name"), names(df))
species_col <- if (length(species_col) > 0) species_col[1] else NULL
# ===================== Compute errors =====================
# Only Train & Test
df_tt <- df %>%
filter(Dataset %in% c("Train", "Test")) %>%
mutate(
# Back-transform from ln(days) -> years
Known_days  = exp(Known_Log_Lifespan),
Pred_days   = exp(Predicted_Log_Lifespan_Model_Averaging),
Known_years = Known_days / 365,
Pred_years  = Pred_days  / 365,
# Absolute Error in years
Abs_Error_years = abs(Pred_years - Known_years),
# Relative Error on ln-days scale (%)
Log_Diff = Predicted_Log_Lifespan_Model_Averaging - Known_Log_Lifespan,
Rel_Error_pct_log_units = ifelse(
abs(Known_Log_Lifespan) < 1e-12,
NA_real_,
abs(Log_Diff) / abs(Known_Log_Lifespan) * 100
),
# *** Force plotting order: Train left, Test right
Dataset = factor(Dataset, levels = c("Train", "Test"))
)
# ===================== Lifespan-bin box plots (final) =====================
# Bin by known ln(lifespan in days); only keep <4, 4–<6, 6–<8, ≥8
df_tt <- df_tt %>%
mutate(
Lifespan_bin = cut(
Known_Log_Lifespan,
breaks = c(-Inf, 4, 6, 8, Inf),
labels = c("<4", "4–<6", "6–<8", "≥8"),
right = FALSE
),
# Force Train left, Test right
Dataset = factor(Dataset, levels = c("Train", "Test"))
)
# ===================== Signed error (Pred - Known) box plot close-up =====================
df_tt <- df_tt %>%
mutate(Error_years = Pred_years - Known_years)  # signed error in years
p_error_bin_box <- ggplot(
df_tt %>% filter(!is.na(Lifespan_bin)),
aes(x = Lifespan_bin, y = Error_years, fill = Dataset)
) +
geom_hline(yintercept = 0, linetype = 2, color = "grey40") +
geom_boxplot(outlier.shape = NA, width = 0.7,
position = position_dodge2(width = 0.8)) +
geom_jitter(aes(group = Dataset),
position = position_jitterdodge(jitter.width = 0.15, dodge.width = 0.8),
alpha = 0.35, size = 1) +
coord_cartesian(ylim = c(-10, 15)) +
labs(
# title = "Prediction Error (Predicted - Known, years)",
x = "ln(Known lifespan days)",
y = "Error (years)"
) +
theme_minimal(base_size = 16)
save_plot(p_error_bin_box, "box_error_years_by_bin_close.png", w = 8, h = 5.2)
# ===================== Signed error (Pred - Known) box plot broad =====================
p_error_bin_box <- ggplot(
df_tt %>% filter(!is.na(Lifespan_bin)),
aes(x = Lifespan_bin, y = Error_years, fill = Dataset)
) +
geom_hline(yintercept = 0, linetype = 2, color = "grey40") +
geom_boxplot(outlier.shape = NA, width = 0.7,
position = position_dodge2(width = 0.8)) +
geom_jitter(aes(group = Dataset),
position = position_jitterdodge(jitter.width = 0.15, dodge.width = 0.8),
alpha = 0.35, size = 1) +
coord_cartesian(ylim = c(-250, 15)) +
labs(
# title = "Prediction Error (Predicted - Known, years)",
x = "ln(Known lifespan days)",
y = "Error (years)"
) +
theme_minimal(base_size = 16)
save_plot(p_error_bin_box, "box_error_years_by_bin_broad.png", w = 8, h = 5.2)
# ----------------- BOX: Absolute error (years), by lifespan bin -----------------
p_abs_bin_box <- ggplot(
df_tt %>% filter(!is.na(Lifespan_bin)),
aes(x = Lifespan_bin, y = pmax(Abs_Error_years, 1e-6), fill = Dataset)
) +
geom_boxplot(outlier.shape = NA, width = 0.7, position = position_dodge2(width = 0.8)) +
geom_jitter(aes(group = Dataset),
position = position_jitterdodge(jitter.width = 0.15, dodge.width = 0.8),
alpha = 0.35, size = 1) +
scale_y_log10(
breaks = c(0.01, 0.1, 1, 10, 100),
labels = c("0.01","0.1","1","10","100")
) +
labs(
# title = "Absolute Error by Known Lifespan Bin",
x = "ln(Known lifespan days)",
y = "Absolute error (years)"
) +
theme_minimal(base_size = 16)
save_plot(p_abs_bin_box, "box_abs_error_years_by_bin_log10.png", w = 8, h = 5.2)
# ----------------- BOX: Relative error (%), ln-days scale, by lifespan bin -----------------
pct_breaks <- c(0.01, 0.1, 1, 10, 100)
pct_labels <- paste0(pct_breaks, "%")
p_rel_bin_box <- ggplot(
df_tt %>% filter(!is.na(Lifespan_bin)),
aes(x = Lifespan_bin, y = pmax(Rel_Error_pct_log_units, 1e-4), fill = Dataset)
) +
geom_boxplot(outlier.shape = NA, width = 0.7, position = position_dodge2(width = 0.8), na.rm = TRUE) +
geom_jitter(aes(group = Dataset),
position = position_jitterdodge(jitter.width = 0.15, dodge.width = 0.8),
alpha = 0.35, size = 1, na.rm = TRUE) +
scale_y_log10(breaks = pct_breaks, labels = pct_labels) +
labs(
# title = "Relative Error (%) on ln-days by Known Lifespan Bin",
x = "ln(Known lifespan days)",
y = "Relative error (%)"
) +
theme_minimal(base_size = 16)
save_plot(p_rel_bin_box, "box_rel_error_pct_ln_days_by_bin_log10.png", w = 8, h = 5.2)
setwd("/Users/yuikikondo/Desktop/Github_code/protostome_lifespan_prediction_model/06_cross_clade_models_by_Ecdysozoa_and_Spiralia/06_03_Trian_by_Spiralia_Test_by_Ecdysozoa")
# ===================== Setup =====================
suppressPackageStartupMessages({
library(readr)
library(dplyr)
library(ggplot2)
library(tidyr)
library(stringr)
library(ggpubr)
})
input_path <- "log_lifespan_predictions.csv"
output_dir <- dirname(input_path)
# Colors for groups
COLORS <- c("Spiralia (Train)" = "#6a3d9a",
"Ecdysozoa (Test)" = "#33a02c")
# Helper: safe saver
save_plot <- function(p, fname, w = 7, h = 5, dpi = 300) {
out <- file.path(output_dir, fname)
ggsave(filename = out, plot = p, width = w, height = h, dpi = dpi)
message("Wrote: ", out)
}
# ===================== Load =====================
df <- read_csv(input_path, show_col_types = FALSE)
req_cols <- c("Dataset", "Known_Log_Lifespan", "Predicted_Log_Lifespan_Model_Averaging")
missing <- setdiff(req_cols, names(df))
if (length(missing) > 0) stop("Missing required column(s): ", paste(missing, collapse = ", "))
# Keep a species/name column if present (optional)
species_col <- intersect(c("Organism.Name","Organism_Name","Species","Final_Tip_Name"), names(df))
species_col <- if (length(species_col) > 0) species_col[1] else NULL
# ===================== Compute errors =====================
df_tt <- df %>%
filter(Dataset %in% c("Train", "Test")) %>%
mutate(
# Rename datasets
Dataset = recode(Dataset,
"Train" = "Spiralia (Train)",
"Test"  = "Ecdysozoa (Test)"),
# Back-transform from ln(days) -> years
Known_days  = exp(Known_Log_Lifespan),
Pred_days   = exp(Predicted_Log_Lifespan_Model_Averaging),
Known_years = Known_days / 365,
Pred_years  = Pred_days  / 365,
# Absolute Error in years
Abs_Error_years = abs(Pred_years - Known_years),
# Relative Error on ln-days scale (%)
Log_Diff = Predicted_Log_Lifespan_Model_Averaging - Known_Log_Lifespan,
Rel_Error_pct_log_units = ifelse(
abs(Known_Log_Lifespan) < 1e-12,
NA_real_,
abs(Log_Diff) / abs(Known_Log_Lifespan) * 100
),
# Force plotting order
Dataset = factor(Dataset, levels = c("Spiralia (Train)", "Ecdysozoa (Test)"))
)
rlang::last_trace()
rlang::last_trace(drop = FALSE)
